// /secure/master.c - Master object for Dawn of the Dragons
// Optimized for FluffOS, March 4, 2025
// Generated by Grok 3, based on Discworld master.c

#include <config.h>
#include <living.h>
#include "/include/master.h" // Relative to mudlib directory

#define ROOT "Root"
#define TRUSTEES ([ ROOT : 1, "archaon" : 1 ]) // Adjust for your setup

nosave mapping trustees = TRUSTEES;
nosave int boot_time;

void create() {
    string log_path;
    boot_time = time();
    seteuid(0); // Root euid for master
    log_path = "/log/startup.log"; // Relative to mudlib directory
    if (file_size(log_path) == -1) {
        write("Debug: Log file doesnâ€™t exist yet, creating...\n");
        write_file(log_path, ""); // Initialize if missing
    }
    if (!write_file(log_path, sprintf("Master booted: %s\n", ctime(boot_time)))) {
        write("Warning: Failed to write to " + log_path + "\n");
        write("Debug: File size = " + file_size(log_path) + ", euid = " + geteuid(this_object()) + "\n");
    } else {
        write("Debug: Successfully wrote to " + log_path + "\n");
    }
}

string get_root_uid() {
    return ROOT; // Matches Discworld original
}

string get_bb_uid() {
    return "Room"; // Matches Discworld original
}

string creator_file(string fname) {
    string *parts = explode(fname, "/");
    if (sizeof(parts) > 1) {
        if (parts[0] == "secure" || parts[0] == "std") return ROOT;
        return parts[0]; // Domain-based creator
    }
    return ROOT;
}

string author_file(string fname) {
    string *parts = explode(fname, "/");
    if (sizeof(parts) > 1) {
        if (parts[0] == "secure" || parts[0] == "std") return ROOT;
        return parts[0]; // Consistent with creator_file
    }
    return ROOT;
}

string domain_file(string fname) {
    string *parts = explode(fname, "/");
    if (sizeof(parts) > 1 && parts[0] != "secure" && parts[0] == "std") {
        return parts[0]; // Fallback to domain
    }
    return "bb_ui"; // Discworld fallback
}

object connect() { // Removed int port parameter
    object login = clone_object("/secure/login");
    if (!login) {
        write("Error: Could not create login object.\n");
        return 0;
    }
    return login;
}

void log_error(string file, string err) {
    if (!write_file("/log/errors.log", sprintf("%s: %s: %s\n", ctime(time()), file, err))) {
        write("Warning: Could not log error to /log/errors.log\n");
    }
}

string valid_read(string path, object caller) {
    string euid = geteuid(caller);
    if (euid == ROOT || path[0..7] == "/secure/") return path;
    return 0; // Deny non-root reads outside secure
}

string valid_write(string path, object caller) {
    string euid = geteuid(caller);
    if (euid == ROOT || path[0..3] == "/log") return path;
    return 0; // Restrict writes
}

int valid_object(object ob) {
    return 1; // Allow all objects for now
}

void preload(string file) {
    if (file_size(file + ".c") > 0) {
        catch(load_object(file));
    }
}

int query_port() { return 3000; } // Matches dw.cfg

void external_start(int cmd, string args, string read_func, string write_func, string close_func) {
    if (!write_file("/log/external.log", sprintf("External call: %d, %s\n", cmd, args))) {
        write("Warning: Could not log external call\n");
    }
}

void destruct(object ob) {
    if (ob) destruct(ob);
}

int query_trustee(mixed str) {
    if (pointerp(str)) {
        return sizeof(filter(str, (: geteuid($1) == ROOT || trustees[geteuid($1)] :))) == sizeof(str);
    }
    return (str == ROOT) || trustees[str];
}
